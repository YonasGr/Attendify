package com.attendify.app.ui.instructor

import android.graphics.Bitmap
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.attendify.app.data.model.AttendanceRecord
import com.attendify.app.data.model.Course
import com.attendify.app.data.model.Session
import com.attendify.app.data.repository.AuthRepository
import com.attendify.app.data.repository.NetworkRepository
import com.attendify.app.utils.QRCodeGenerator
import com.attendify.app.utils.Resource
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch
import javax.inject.Inject

/**
 * ViewModel for Instructor Dashboard and related screens, with improved performance and stability.
 */
@HiltViewModel
class InstructorViewModel @Inject constructor(
    private val authRepository: AuthRepository,
    private val networkRepository: NetworkRepository
) : ViewModel() {

    private val _courses = MutableStateFlow<List<Course>>(emptyList())
    val courses: StateFlow<List<Course>> = _courses.asStateFlow()

    private val _sessions = MutableStateFlow<List<Session>>(emptyList())
    val sessions: StateFlow<List<Session>> = _sessions.asStateFlow()

    private val _qrCodeBitmap = MutableStateFlow<Bitmap?>(null)
    val qrCodeBitmap: StateFlow<Bitmap?> = _qrCodeBitmap.asStateFlow()

    private val _uiState = MutableStateFlow<Resource<Unit>>(Resource.Loading())
    val uiState: StateFlow<Resource<Unit>> = _uiState.asStateFlow()

    init {
        loadInstructorData()
    }

    fun loadInstructorData() {
        viewModelScope.launch {
            _uiState.value = Resource.Loading()
            try {
                val user = authRepository.getCurrentUser()
                if (user == null) {
                    _uiState.value = Resource.Error("User not authenticated.")
                    return@launch
                }

                networkRepository.getCoursesByInstructor(user.id).collectLatest { courseResource ->
                    if (courseResource is Resource.Success) {
                        _courses.value = courseResource.data ?: emptyList()
                        // Fetch sessions for the courses
                        fetchSessionsForCourses(courseResource.data ?: emptyList())
                    } else if (courseResource is Resource.Error) {
                        _uiState.value = Resource.Error(courseResource.message ?: "Failed to load courses.")
                    }
                }
            } catch (e: Exception) {
                _uiState.value = Resource.Error(e.message ?: "An unexpected error occurred.")
            }
        }
    }

    private fun fetchSessionsForCourses(courses: List<Course>) {
        viewModelScope.launch {
            courses.forEach { course ->
                networkRepository.getSessionsByCourse(course.id).collectLatest { sessionResource ->
                    if (sessionResource is Resource.Success) {
                        val existingSessions = _sessions.value.toMutableList()
                        // Replace or add new sessions
                        sessionResource.data?.forEach { newSession ->
                            val index = existingSessions.indexOfFirst { it.id == newSession.id }
                            if (index != -1) {
                                existingSessions[index] = newSession
                            } else {
                                existingSessions.add(newSession)
                            }
                        }
                        _sessions.value = existingSessions.sortedByDescending { it.scheduledDate }
                    }
                }
            }
            _uiState.value = Resource.Success(Unit) // Data loaded successfully
        }
    }

    fun createCourse(code: String, name: String, description: String?, semester: String, year: Int) {
        viewModelScope.launch {
            _uiState.value = Resource.Loading()
            val user = authRepository.getCurrentUser()
            if (user == null) {
                _uiState.value = Resource.Error("User not authenticated.")
                return@launch
            }

            val newCourse = Course(
                id = "", // ID will be generated by the backend
                code = code,
                name = name,
                description = description,
                instructorId = user.id,
                semester = semester,
                year = year
            )

            networkRepository.createCourse(newCourse).collectLatest { result ->
                if (result is Resource.Success) {
                    loadInstructorData() // Refresh data on success
                    _uiState.value = Resource.Success(Unit) // Map result to Resource<Unit>
                } else if (result is Resource.Error) {
                    _uiState.value = Resource.Error(result.message ?: "Failed to create course")
                }
            }
        }
    }

    fun createSession(
        courseId: String, title: String, scheduledDate: Long, startTime: String, endTime: String, isActive: Boolean = true
    ) {
        viewModelScope.launch {
            _uiState.value = Resource.Loading()
            val newSession = Session(
                id = "", // ID generated by backend
                courseId = courseId,
                title = title,
                scheduledDate = scheduledDate,
                startTime = startTime,
                endTime = endTime,
                qrCode = "", // Generated by backend
                isActive = isActive
            )

            networkRepository.createSession(newSession).collectLatest { result ->
                if (result is Resource.Success) {
                    loadInstructorData() // Refresh on success
                    _uiState.value = Resource.Success(Unit)
                } else if (result is Resource.Error) {
                    _uiState.value = Resource.Error(result.message ?: "Failed to create session")
                }
            }
        }
    }

    fun generateQrCodeForSession(session: Session) {
        viewModelScope.launch {
            try {
                val qrCodeContent = "attendify://checkin?sessionId=${session.id}"
                _qrCodeBitmap.value = QRCodeGenerator.generateQRCode(qrCodeContent)
            } catch (e: Exception) {
                _uiState.value = Resource.Error("Could not generate QR code: ${e.message}")
            }
        }
    }

    fun generateQrCodeForCourse(course: Course) {
        viewModelScope.launch {
            try {
                val qrCodeContent = "attendify://enroll?courseId=${course.id}"
                _qrCodeBitmap.value = QRCodeGenerator.generateQRCode(qrCodeContent)
            } catch (e: Exception) {
                _uiState.value = Resource.Error("Could not generate QR code: ${e.message}")
            }
        }
    }

    fun getAttendanceForSession(sessionId: String): StateFlow<Resource<List<AttendanceRecord>>> {
        val attendanceFlow = MutableStateFlow<Resource<List<AttendanceRecord>>>(Resource.Loading())
        viewModelScope.launch {
            networkRepository.getAttendanceBySession(sessionId).collectLatest {
                attendanceFlow.value = it
            }
        }
        return attendanceFlow.asStateFlow()
    }

    fun clearQrCode() {
        _qrCodeBitmap.value = null
    }
}
